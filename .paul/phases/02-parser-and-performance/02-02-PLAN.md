---
phase: 02-parser-and-performance
plan: 02
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/axon/core/ingestion/community.py
  - tests/core/test_community.py
autonomous: true
---

<objective>
## Goal
Parallelize community detection by splitting the call graph into weakly connected
components and running the Leiden algorithm on each component independently via
`ThreadPoolExecutor`.

## Purpose
Community detection accounts for 19% of cold-start indexing time (v0.3 Phase 2
profiling). The Leiden algorithm is currently run once on the full graph. Most
real codebases have many disconnected components (isolated utility modules, test
helpers, separate subsystems). Splitting allows parallel execution and skips
components too small for meaningful community detection.

## Output
- `community.py` refactored to process components in parallel
- New helper `_partition_component()` for per-component Leiden execution
- Tests covering multi-component graphs and single-component fallback
</objective>

<context>
## Project Context
@.paul/PROJECT.md
@.paul/STATE.md

## Source Files
@src/axon/core/ingestion/community.py

## Current Implementation Analysis
`process_communities()` currently:
1. Calls `export_to_igraph()` → full directed igraph
2. Calls `leidenalg.find_partition(ig_graph, ModularityVertexPartition)` — single-threaded on whole graph
3. Iterates partitions to create community nodes and MEMBER_OF relationships

## Parallelization Strategy
1. Convert to undirected for component detection:
   `undirected = ig_graph.as_undirected()`
2. Find weakly connected components:
   `components = undirected.components(mode="WEAK")`
3. For each component with ≥3 vertices, extract the induced subgraph (directed)
   and run Leiden on it independently
4. Collect results and create community nodes (same as before)

Key mapping challenge: igraph `subgraph()` re-indexes vertices 0..N-1.
The subgraph vertices retain their original indices accessible via
`subgraph.vs["name"]` if we set vertex names, or we pass the original
vertex IDs alongside the subgraph.

Simplest correct approach:
- For each component, extract `member_vertex_ids` (original indices)
- Create subgraph: `sub = ig_graph.subgraph(member_vertex_ids)`
- Run Leiden on `sub`
- Map sub-vertex indices back via `member_vertex_ids[sub_idx]` → original idx
  → `index_to_node_id[orig_idx]` → Axon node ID

## Thread Safety Note
leidenalg operates on separate igraph objects per call. Python C extensions
that release the GIL run truly in parallel. If leidenalg holds the GIL,
`ThreadPoolExecutor` degrades to sequential but remains correct.
The plan uses `ThreadPoolExecutor(max_workers=4)` — if GIL-bound, the
fallback is no worse than the current sequential implementation.
</context>

<acceptance_criteria>

## AC-1: Single large component → same behavior as before
```gherkin
Given a call graph where all nodes are in one connected component
When process_communities() is called
Then community nodes are created identical to the current implementation
And no regression in community count or labels
```

## AC-2: Multi-component graph → each component processed independently
```gherkin
Given a call graph with two disconnected clusters of ≥3 nodes each
When process_communities() is called
Then communities are detected in both clusters independently
And MEMBER_OF relationships exist for members of each cluster
```

## AC-3: Small components (< 3 nodes) are skipped without error
```gherkin
Given a call graph with one isolated node and one cluster of 5 nodes
When process_communities() is called
Then community detection runs only on the 5-node cluster
And no error is raised for the isolated node
```

## AC-4: Empty or too-small graph returns 0 (unchanged behavior)
```gherkin
Given a call graph with fewer than 3 total nodes
When process_communities() is called
Then 0 is returned and no community nodes are created
```

## AC-5: All existing 752 tests still pass
```gherkin
Given the test suite at the pre-plan baseline
When `uv run pytest tests/` is run
Then all tests pass with no new failures
```

</acceptance_criteria>

<tasks>

<task type="auto">
  <name>Task 1: Add _partition_component helper and refactor process_communities</name>
  <files>src/axon/core/ingestion/community.py</files>
  <action>
    Add a new module-level helper function `_partition_component` that runs Leiden
    on a single component and returns the raw partition (list of member index lists):

    ```python
    def _partition_component(
        ig_graph: ig.Graph,
        member_vertex_ids: list[int],
    ) -> list[list[int]]:
        """Run Leiden on one connected component. Returns list of member groups.

        Each group is a list of ORIGINAL vertex indices (from the full graph),
        not sub-graph indices.

        Args:
            ig_graph: The full directed igraph.
            member_vertex_ids: Original vertex indices belonging to this component.

        Returns:
            List of groups, where each group is a list of original vertex indices.
            Returns empty list if component is too small.
        """
        if len(member_vertex_ids) < 3:
            return []

        sub = ig_graph.subgraph(member_vertex_ids)
        partition = leidenalg.find_partition(sub, leidenalg.ModularityVertexPartition)

        # Map sub-graph indices back to original graph indices
        result: list[list[int]] = []
        for members in partition:
            original_ids = [member_vertex_ids[sub_idx] for sub_idx in members]
            result.append(original_ids)
        return result
    ```

    Refactor `process_communities()` to use component-based parallel processing:

    ```python
    def process_communities(
        graph: KnowledgeGraph,
        min_community_size: int = 2,
    ) -> int:
        ig_graph, index_to_node_id = export_to_igraph(graph)

        if ig_graph.vcount() < 3:
            logger.debug(
                "Call graph too small for community detection (%d nodes), skipping.",
                ig_graph.vcount(),
            )
            return 0

        # Split into weakly connected components
        undirected = ig_graph.as_undirected()
        components = undirected.components(mode="WEAK")
        component_groups: list[list[int]] = [list(comp) for comp in components]

        logger.debug(
            "Community detection: %d weakly connected components found.",
            len(component_groups),
        )

        # Run Leiden per component in parallel
        all_partitions: list[list[int]] = []
        with ThreadPoolExecutor() as executor:
            futures = {
                executor.submit(_partition_component, ig_graph, comp): comp
                for comp in component_groups
                if len(comp) >= 3
            }
            for future in futures:
                all_partitions.extend(future.result())

        # Compute overall modularity for metadata (single partition on full graph
        # is expensive; use component count as proxy or skip)
        # NOTE: modularity per community is not recomputed here — use 0.0 as sentinel
        # if per-component modularity is needed, each call returns partition.modularity.
        # For simplicity, use 0.0 and add a TODO for future enhancement.
        modularity_score = 0.0

        community_count = 0
        for i, original_member_ids in enumerate(all_partitions):
            if len(original_member_ids) < min_community_size:
                continue

            member_ids = [index_to_node_id[idx] for idx in original_member_ids]

            community_id = generate_id(NodeLabel.COMMUNITY, f"community_{i}")
            label = generate_label(graph, member_ids)

            community_node = GraphNode(
                id=community_id,
                label=NodeLabel.COMMUNITY,
                name=label,
                properties={
                    "cohesion": modularity_score,
                    "symbol_count": len(member_ids),
                },
            )
            graph.add_node(community_node)

            for member_id in member_ids:
                rel_id = f"member_of:{member_id}->{community_id}"
                graph.add_relationship(
                    GraphRelationship(
                        id=rel_id,
                        type=RelType.MEMBER_OF,
                        source=member_id,
                        target=community_id,
                    )
                )

            community_count += 1
            logger.info(
                "Community %d: %r with %d members",
                i,
                label,
                len(member_ids),
            )

        logger.info(
            "Community detection complete: %d communities created.", community_count
        )
        return community_count
    ```

    Add `from concurrent.futures import ThreadPoolExecutor` to the imports at top of file.

    **Important:** The original implementation logged `modularity_score` from the
    single full-graph partition. With per-component processing, per-component
    modularity requires capturing it from each `_partition_component` call. This plan
    uses `0.0` as a placeholder. If exact modularity is needed, refactor
    `_partition_component` to return `(groups, modularity)` — defer to a follow-up.
  </action>
  <verify>
    ```bash
    uv run python -c "from axon.core.ingestion.community import process_communities, _partition_component; print('OK')"
    ```
    Import succeeds without error.
  </verify>
  <done>
    Implementation in place. _partition_component and ThreadPoolExecutor-based
    process_communities are importable and structurally correct.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add tests for multi-component and edge cases</name>
  <files>tests/core/test_community.py</files>
  <action>
    Locate `tests/core/test_community.py`. Add the following test classes after
    existing tests (do not remove or modify existing tests):

    ```python
    class TestProcessCommunitiesMultiComponent:
        """Two disconnected clusters are both processed."""

        def test_two_components_both_detected(self) -> None:
            """Graph with two disconnected 3-node clusters → communities in both."""
            graph = KnowledgeGraph()

            # Cluster A: nodes 0,1,2 fully connected
            nodes_a = [_make_function_node(f"a{i}", f"file_a.py") for i in range(3)]
            for n in nodes_a:
                graph.add_node(n)
            # A is fully connected: 0→1, 1→2, 2→0
            _add_calls(graph, nodes_a[0], nodes_a[1])
            _add_calls(graph, nodes_a[1], nodes_a[2])
            _add_calls(graph, nodes_a[2], nodes_a[0])

            # Cluster B: nodes 3,4,5 fully connected (disconnected from A)
            nodes_b = [_make_function_node(f"b{i}", f"file_b.py") for i in range(3)]
            for n in nodes_b:
                graph.add_node(n)
            _add_calls(graph, nodes_b[0], nodes_b[1])
            _add_calls(graph, nodes_b[1], nodes_b[2])
            _add_calls(graph, nodes_b[2], nodes_b[0])

            count = process_communities(graph)
            assert count >= 2

        def test_small_component_skipped(self) -> None:
            """Isolated node + 3-node cluster → only cluster gets community."""
            graph = KnowledgeGraph()

            # Isolated node
            isolated = _make_function_node("isolated", "isolated.py")
            graph.add_node(isolated)

            # 3-node cluster
            nodes = [_make_function_node(f"c{i}", "cluster.py") for i in range(3)]
            for n in nodes:
                graph.add_node(n)
            _add_calls(graph, nodes[0], nodes[1])
            _add_calls(graph, nodes[1], nodes[2])
            _add_calls(graph, nodes[2], nodes[0])

            count = process_communities(graph)
            # Isolated node should not form a community
            community_nodes = graph.get_nodes_by_label(NodeLabel.COMMUNITY)
            member_of_rels = graph.get_relationships_by_type(RelType.MEMBER_OF)
            member_ids = {r.source for r in member_of_rels}
            assert isolated.id not in member_ids
    ```

    The test helpers `_make_function_node` and `_add_calls` likely already exist in
    `test_community.py`. If not, add them:

    ```python
    def _make_function_node(name: str, file_path: str) -> GraphNode:
        return GraphNode(
            id=generate_id(NodeLabel.FUNCTION, file_path, name),
            label=NodeLabel.FUNCTION,
            name=name,
            file_path=file_path,
        )

    def _add_calls(graph: KnowledgeGraph, src: GraphNode, tgt: GraphNode) -> None:
        rel_id = f"calls:{src.id}->{tgt.id}"
        graph.add_relationship(
            GraphRelationship(
                id=rel_id,
                type=RelType.CALLS,
                source=src.id,
                target=tgt.id,
            )
        )
    ```
  </action>
  <verify>
    ```bash
    uv run pytest tests/core/test_community.py -v -k "MultiComponent or small_component"
    ```
    New tests pass.
  </verify>
  <done>AC-2, AC-3 satisfied: multi-component and small-component edge cases tested</done>
</task>

<task type="auto">
  <name>Task 3: Verify full test suite</name>
  <files>(no changes)</files>
  <action>
    Run the full test suite:
    ```bash
    uv run pytest tests/ -q
    ```
    Do not modify any files in this task.
  </action>
  <verify>
    Output shows ≥752 passed, zero failures, zero errors.
  </verify>
  <done>AC-1, AC-4, AC-5 satisfied: all tests pass</done>
</task>

</tasks>

<boundaries>

## DO NOT CHANGE
- `src/axon/core/ingestion/community.py` `export_to_igraph()` function — interface is stable
- `src/axon/core/ingestion/community.py` `generate_label()` function — label logic unchanged
- Any existing test in `test_community.py` — only add new tests
- All files outside `community.py` and `test_community.py`

## SCOPE LIMITS
- This plan only parallelizes community detection within a single indexing run
- Do NOT attempt cross-run caching of community results
- Do NOT change the Leiden algorithm or switch to a different partitioning algorithm
- Do NOT add configuration options for max_workers — `ThreadPoolExecutor()` default is fine
- Modularity score stored as 0.0 placeholder is acceptable for this plan

</boundaries>

<verification>
Before declaring plan complete:
- [ ] `uv run python -c "from axon.core.ingestion.community import _partition_component"` — no ImportError
- [ ] `uv run pytest tests/core/test_community.py -v` — all community tests pass
- [ ] `uv run pytest tests/ -q` — ≥752 tests pass, zero failures
</verification>

<success_criteria>
- `_partition_component()` helper added to community.py
- `process_communities()` uses `ThreadPoolExecutor` for per-component Leiden
- `from concurrent.futures import ThreadPoolExecutor` imported
- Multi-component graph tests added
- All existing tests still pass
</success_criteria>

<output>
After completion, create `.paul/phases/02-parser-and-performance/02-02-SUMMARY.md`
</output>
