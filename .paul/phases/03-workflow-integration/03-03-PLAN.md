---
phase: 03-workflow-integration
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - src/axon/mcp/server.py
  - src/axon/mcp/tools.py
  - tests/mcp/test_tools.py
autonomous: true
---

<objective>
## Goal
Improve the MCP query API ergonomics for AI agent consumption via two targeted changes:
(1) rewrite tool descriptions to be agent-actionable with workflow guidance, and
(2) add a `language` filter to `axon_query` and file-path disambiguation to `axon_context`.

## Purpose
The current tool descriptions are terse and don't tell agents *when* to use each tool or what to do next. Agents calling `axon_context` with an ambiguous symbol name silently get the wrong result. These gaps reduce quality of agent-driven codebase understanding.

## Output
- `server.py`: richer TOOLS descriptions with usage guidance + fixed `axon_context` description
- `tools.py`: `handle_query` accepts `language` filter; `handle_context` supports `file:symbol` format and returns disambiguation list on ambiguity
- `tests/mcp/test_tools.py`: tests for language filter and disambiguation
</objective>

<context>
## Project Context
@.paul/PROJECT.md
@.paul/STATE.md

## Source Files
@src/axon/mcp/server.py
@src/axon/mcp/tools.py
@src/axon/mcp/resources.py
@tests/mcp/test_tools.py
</context>

<acceptance_criteria>

## AC-1: Agent-optimized tool descriptions
```gherkin
Given an MCP client calls axon_list_tools
When it inspects tool descriptions
Then each tool description includes: what the tool returns, when to use it,
     and which tool to call next (workflow chaining guidance)
And axon_context description no longer claims "community membership"
     since that is not currently returned
```

## AC-2: Language filter on axon_query
```gherkin
Given an indexed codebase with Python and Elixir symbols
When axon_query is called with query="parse" and language="python"
Then only symbols with language="python" are returned
And when called without language parameter, all languages are returned (existing behaviour)
```

## AC-3: File-path disambiguation in axon_context
```gherkin
Given a codebase with two symbols named "parse" in different files
When axon_context is called with symbol="parse"
Then the response lists all matching symbols with their file paths
And instructs the agent to retry with "file.py:parse" format to be precise
```

## AC-4: Precise file-path lookup in axon_context
```gherkin
Given a symbol "parse" exists in "src/axon/parsers/python.py"
When axon_context is called with symbol="src/axon/parsers/python.py:parse"
Then the exact symbol from that file is returned
And not any other symbol named "parse" from another file
```

## AC-5: Tests pass
```gherkin
Given the modified tools.py
When the full MCP test suite is run
Then all existing tests pass
And new tests cover: language filter, single match, multi-match disambiguation, file:symbol lookup
```

</acceptance_criteria>

<tasks>

<task type="auto">
  <name>Task 1: Rewrite tool descriptions in server.py</name>
  <files>src/axon/mcp/server.py</files>
  <action>
    Rewrite the `description` field for each tool in the TOOLS list to be agent-actionable.
    Each description should follow this pattern:
    - What it does (1 sentence)
    - When to use it
    - What it returns
    - Recommended next tool (chaining)

    Guidelines per tool:
    - `axon_list_repos`: "List all indexed repositories. Use first to discover which repos are available. Returns name, path, file/symbol counts."
    - `axon_query`: "Search the knowledge graph by natural language or symbol name (hybrid keyword+vector). Use when you need to find relevant functions, classes, or files. Returns ranked symbols with file path, label, and snippet. Follow with axon_context on a specific result for full details."
    - `axon_context`: "Get a 360-degree view of a symbol: callers, callees, and type references. Use before modifying a symbol to understand its full dependency graph. Returns callers, callees, type refs, signature, and dead-code status. Follow with axon_impact to see blast radius." (Remove mention of "community membership" — not currently returned.)
    - `axon_impact`: "Blast radius analysis — find all symbols affected by changing a given symbol, grouped by hop depth. Use before refactoring to understand risk. Returns affected symbols per depth level with confidence scores."
    - `axon_dead_code`: "List all symbols detected as dead (unreachable) code. Use during code review or cleanup. Returns symbols grouped by file."
    - `axon_detect_changes`: "Map a git diff to the symbols it touches. Pass `git diff HEAD` output. Use to understand which symbols a set of changes affects before reviewing or testing. Follow with axon_impact on each affected symbol."
    - `axon_cypher`: "Execute a raw read-only Cypher query directly against the knowledge graph. Use for custom queries not covered by other tools. Only MATCH/RETURN queries are allowed; write operations are rejected."

    Also update the `axon_query` inputSchema to add the optional `language` parameter:
    ```python
    "language": {
        "type": "string",
        "description": "Filter results to a specific language (e.g. 'python', 'elixir', 'typescript'). Optional.",
    },
    ```

    Do NOT change any other logic in server.py.
  </action>
  <verify>
    Read the TOOLS list — confirm each description mentions when to use + what to return + next step.
    Confirm axon_context description does not mention community membership.
    Confirm axon_query schema has optional "language" property.
  </verify>
  <done>AC-1 satisfied: descriptions are agent-actionable and schema extended for language filter</done>
</task>

<task type="auto">
  <name>Task 2: Language filter + file:symbol disambiguation in tools.py</name>
  <files>src/axon/mcp/tools.py</files>
  <action>
    **A. Language filter in `handle_query`:**

    Add `language: str | None = None` parameter to `handle_query`.
    After the existing `hybrid_search` call, if `language` is provided, post-filter:
    ```python
    if language:
        lang_lower = language.lower()
        results = [r for r in results if r.language and r.language.lower() == lang_lower]
    ```
    If filtering produces an empty list, return:
    `f"No results found for '{query}' in language '{language}'."`
    instead of the generic "No results found" message.

    Update `_dispatch_tool` in server.py to pass `language=arguments.get("language")` to `handle_query`.

    **B. File-path disambiguation in `handle_context`:**

    At the start of `handle_context`, before calling `_resolve_symbol`, parse the symbol string:
    - If `symbol` contains `:` (but is not a Windows drive path), split into `(file_hint, sym_name)` on the *last* `:`.
    - Example: `"src/axon/parsers/python.py:parse"` → file_hint=`"src/axon/parsers/python.py"`, sym_name=`"parse"`.

    For file-path-qualified lookup:
    1. Use `fts_search(sym_name, limit=20)` to get candidates.
    2. Filter candidates where `result.file_path` ends with `file_hint` (suffix match to handle relative vs absolute).
    3. If exactly one match: proceed normally.
    4. If zero matches: return `f"Symbol '{sym_name}' not found in '{file_hint}'."`

    For unqualified lookup (no `:`):
    1. Call `_resolve_symbol(storage, symbol)` with `limit=5` (instead of 1) to detect ambiguity.
       Update `_resolve_symbol` to accept a `limit` parameter (default 1 for backward compat).
    2. If more than 1 result found and they have different `file_path`s:
       - Return disambiguation message:
         ```
         Multiple symbols named '{symbol}' found. Specify file path to disambiguate:
           1. {name}  ({label}) — {file_path}
           2. {name}  ({label}) — {file_path}
         ...
         Retry with: axon_context(symbol="path/to/file.py:{symbol}")
         ```
    3. If exactly 1 result (or all results have the same file_path): proceed normally.

    Avoid changing the public signature of `_resolve_symbol` in a way that breaks other callers
    (handle_impact uses it with limit=1 implicitly — keep default=1).
  </action>
  <verify>
    Run: python -m pytest tests/mcp/test_tools.py -v
    Confirm existing tests pass (no regressions).
    Manually trace: handle_context("file.py:symbol") parses file_hint and sym_name correctly.
    Manually trace: handle_query(storage, "parse", language="python") filters by language.
  </verify>
  <done>AC-2, AC-3, AC-4 satisfied: language filter works; disambiguation returns list; file:symbol lookup resolves precisely</done>
</task>

<task type="auto">
  <name>Task 3: Add tests for new behaviour</name>
  <files>tests/mcp/test_tools.py</files>
  <action>
    Add test cases to the existing test file (do not create a new file).
    Append to the appropriate existing test classes or add new classes as needed.

    **Tests for language filter (class TestHandleQuery or new class):**
    - `test_language_filter_returns_only_matching_language`: mock storage returns results with mixed languages; calling `handle_query(storage, "x", language="python")` returns only python results.
    - `test_language_filter_no_match`: when filter produces empty list, returns message containing the language name.
    - `test_language_filter_none_returns_all`: when language=None, all results returned (existing behaviour unchanged).

    **Tests for file-path disambiguation (class TestHandleContext or new class):**
    - `test_context_file_colon_symbol_exact`: mock storage fts_search returns 2 results in different files; calling with `"src/foo.py:parse"` returns context for the file-matched one.
    - `test_context_file_colon_not_found`: calling `"nonexistent.py:parse"` returns not-found message for that file.
    - `test_context_disambiguation_multiple_files`: mock returns 3 results for "parse" across 3 files; handle_context("parse") returns disambiguation message listing all 3.
    - `test_context_no_disambiguation_single_result`: mock returns 1 result; existing behaviour (no disambiguation).

    Use the existing mock_storage fixture pattern from the file. Make sure the mock's `fts_search` supports the `limit` parameter (it likely already does since it's a Mock).
  </action>
  <verify>
    Run: python -m pytest tests/mcp/test_tools.py -v
    All tests pass including the 7 new ones.
    Run: python -m pytest tests/ -x -q
    Total passing count increases by 7 (671 → 678).
  </verify>
  <done>AC-5 satisfied: all new tests pass, no regressions</done>
</task>

</tasks>

<boundaries>

## DO NOT CHANGE
- `src/axon/core/search/hybrid.py` — language filtering is done post-search, not inside hybrid_search
- `src/axon/core/storage/kuzu_backend.py` — no storage layer changes
- `src/axon/mcp/resources.py` — out of scope for this plan
- Any existing test assertions — do not modify existing tests, only add new ones

## SCOPE LIMITS
- Do NOT add pagination to any tool (next plan or future scope)
- Do NOT add structured/JSON output formats (out of scope)
- Do NOT add community membership to handle_context (deferred — would require new storage query)
- Do NOT change the hybrid_search signature or internals
- Tool logic changes are limited to: language post-filter and file:symbol parsing only

</boundaries>

<verification>
Before declaring plan complete:
- [ ] python -m pytest tests/mcp/test_tools.py -v — all pass (678 total)
- [ ] python -m pytest tests/ -x -q — 678/678 passing, no regressions
- [ ] axon_context description in TOOLS does not mention "community membership"
- [ ] axon_query TOOLS inputSchema has "language" property
- [ ] handle_query accepts language kwarg and post-filters
- [ ] handle_context parses "file.py:symbol" format
- [ ] handle_context returns disambiguation list for ambiguous names
</verification>

<success_criteria>
- All 3 tasks completed
- 678 tests passing (671 prior + 7 new)
- No regressions in existing MCP tests
- Tool descriptions are agent-actionable (include when-to-use, what-it-returns, next-tool)
- Language filter works end-to-end in axon_query
- File:symbol disambiguation works in axon_context
</success_criteria>

<output>
After completion, create `.paul/phases/03-workflow-integration/03-03-SUMMARY.md`
</output>
