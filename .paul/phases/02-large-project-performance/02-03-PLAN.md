---
phase: 02-large-project-performance
plan: 03
type: execute
wave: 1
depends_on: ["02-02"]
files_modified:
  - src/axon/core/ingestion/walker.py
  - src/axon/core/ingestion/parser_phase.py
  - tests/core/test_parser_phase.py
autonomous: true
---

<objective>
## Goal

Tune the parallel worker pool in `walk_repo()` and `process_parsing()` from a
hardcoded `max_workers=8` to a CPU-adaptive default (`None` → Python's
`min(32, cpu_count + 4)`), and add parallel correctness tests that verify the
multi-threaded parse path produces identical results to the serial path.

## Discovery

Parallel parsing was already implemented in commit `8e71d2b` (Phase 1 language
coverage), predating Phase 2.  ROADMAP item 02-03 "Parallel parsing worker pool"
was written without that knowledge.  The implementation is correct; what remains
is:

1. Replace the hardcoded `max_workers=8` default with Python's adaptive default
   (`None` passed to `ThreadPoolExecutor` → `min(32, cpu_count + 4)`).
2. Add tests that verify the parallel path is deterministic and produces identical
   output to a serial run.

## Purpose

Hardcoding 8 workers caps performance on machines with more cores and wastes
threads on smaller machines.  Correctness tests guard against future regressions
in the parallel parse path (currently zero coverage for that code path).

## Output

- `walker.py` and `parser_phase.py`: `max_workers` defaults changed from `8` to `None`
- `test_parser_phase.py`: new `TestParallelParsing` class (2 tests)
</objective>

<context>
## Project Context
@.paul/PROJECT.md
@.paul/ROADMAP.md
@.paul/STATE.md

## Prior Work
@.paul/phases/02-large-project-performance/02-02-SUMMARY.md

## Source Files
@src/axon/core/ingestion/walker.py
@src/axon/core/ingestion/parser_phase.py
@tests/core/test_parser_phase.py
</context>

<acceptance_criteria>

## AC-1: Adaptive worker count
```gherkin
Given  walk_repo() and process_parsing() with no explicit max_workers argument
When   called on any machine
Then   the ThreadPoolExecutor uses Python's default (min(32, cpu_count + 4))
       rather than a hardcoded cap of 8
```

## AC-2: Parallel correctness — serial vs parallel produce identical graphs
```gherkin
Given  a known set of Python source files
When   process_parsing() runs with max_workers=1 (serial)
  And  process_parsing() runs with max_workers=4 (parallel)
Then   both graphs contain the same node count and relationship count
```

## AC-3: Parallel correctness — deterministic across repeated calls
```gherkin
Given  the same set of source files
When   process_parsing() is called twice with the same max_workers
Then   both runs return lists of FileParseData with identical symbol counts
       per file (same order preserved by executor.map)
```

## AC-4: No regression
```gherkin
Given  the full test suite (650+ tests)
When   run after changes
Then   all tests pass with no new failures
```

</acceptance_criteria>

<tasks>

<task type="auto">
  <name>Task 1: Replace hardcoded max_workers=8 with None in walker.py and parser_phase.py</name>
  <files>src/axon/core/ingestion/walker.py, src/axon/core/ingestion/parser_phase.py</files>
  <action>
    In both files change the `max_workers` parameter signature from
    `max_workers: int = 8` to `max_workers: int | None = None`.

    No other changes needed — `ThreadPoolExecutor(max_workers=None)` already
    uses `min(32, os.cpu_count() + 4)` (Python 3.8+ default).

    Update the docstrings: change "Defaults to 8" to "Defaults to None (Python
    picks min(32, cpu_count + 4))."

    Avoid: adding any `os.cpu_count()` calls in application code — let
    ThreadPoolExecutor handle it.
    Avoid: changing any call sites (pipeline.py, reindex_files, benchmarks) —
    they don't pass max_workers so they already pick up the new default.
  </action>
  <verify>uv run pytest tests/core/test_walker.py tests/core/test_parser_phase.py -v</verify>
  <done>AC-1 satisfied: signature changed, existing tests pass</done>
</task>

<task type="auto">
  <name>Task 2: Add TestParallelParsing class to test_parser_phase.py</name>
  <files>tests/core/test_parser_phase.py</files>
  <action>
    Append a new test class `TestParallelParsing` at the bottom of the file.

    Use `process_structure` (already imported or add import) to seed File nodes
    before calling `process_parsing`, since the parser phase expects File nodes
    to exist.

    Test 1 — serial vs parallel produce identical graphs:
    ```python
    def test_serial_and_parallel_produce_identical_graphs(self) -> None:
        files = [
            FileEntry(path="a.py", content="def foo(): pass", language="python"),
            FileEntry(path="b.py", content="class Bar:\n    def method(self): pass", language="python"),
            FileEntry(path="c.py", content="def baz(): pass\ndef qux(): pass", language="python"),
        ]
        graph_serial = KnowledgeGraph()
        process_structure(files, graph_serial)
        process_parsing(files, graph_serial, max_workers=1)

        graph_parallel = KnowledgeGraph()
        process_structure(files, graph_parallel)
        process_parsing(files, graph_parallel, max_workers=4)

        assert graph_serial.node_count == graph_parallel.node_count
        assert graph_serial.relationship_count == graph_parallel.relationship_count
    ```

    Test 2 — executor.map preserves order (determinism):
    ```python
    def test_parse_order_is_deterministic(self) -> None:
        files = [
            FileEntry(path="x.py", content="def x1(): pass\ndef x2(): pass", language="python"),
            FileEntry(path="y.py", content="def y1(): pass", language="python"),
        ]
        graph = KnowledgeGraph()
        process_structure(files, graph)
        results = process_parsing(files, graph, max_workers=4)

        assert results[0].file_path == "x.py"
        assert len(results[0].parse_result.symbols) == 2
        assert results[1].file_path == "y.py"
        assert len(results[1].parse_result.symbols) == 1
    ```

    Required imports (add only if not already present at top of test file):
    - `from axon.core.ingestion.structure import process_structure`
    - `from axon.core.ingestion.walker import FileEntry`

    Avoid: mocking ThreadPoolExecutor — test real parallel execution.
    Avoid: testing internal thread count — focus on observable output.
  </action>
  <verify>uv run pytest tests/core/test_parser_phase.py -v -k "Parallel"</verify>
  <done>AC-2 and AC-3 satisfied: both tests pass</done>
</task>

</tasks>

<boundaries>

## DO NOT CHANGE
- `src/axon/core/ingestion/pipeline.py` — not touched in this plan
- `benchmarks/` — benchmark CLI not modified
- Any parser implementation files (`python_lang.py`, `typescript.py`, etc.)
- Storage backend files

## SCOPE LIMITS
- Do not parallelise graph mutation — it is intentionally sequential (KnowledgeGraph is not thread-safe)
- Do not change `max_workers` at call sites — callers that need a specific count already pass it explicitly
- Do not add `os.cpu_count()` to application code — rely on ThreadPoolExecutor's built-in logic

</boundaries>

<verification>
Before declaring plan complete:
- [ ] `uv run pytest tests/core/test_walker.py tests/core/test_parser_phase.py -v` — all pass
- [ ] `uv run pytest` — full suite passes (650+ tests, 0 failures)
- [ ] `grep "max_workers: int = 8" src/axon/core/ingestion/walker.py src/axon/core/ingestion/parser_phase.py` returns nothing (hardcoded 8 removed)
- [ ] `uv run pytest tests/core/test_parser_phase.py -v -k "Parallel"` shows 2 new passing tests
</verification>

<success_criteria>
- Hardcoded `max_workers=8` removed from walker.py and parser_phase.py
- `TestParallelParsing` class with 2 tests passes
- All existing tests continue to pass
- No new dependencies introduced
</success_criteria>

<output>
After completion, create `.paul/phases/02-large-project-performance/02-03-SUMMARY.md`
</output>
